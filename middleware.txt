import { Response, Request, NextFunction } from "express";
import { promisify } from "util";
import jwt, { SigningKeyCallback } from "jsonwebtoken";
import bcrypt from "bcrypt";
import { catchAsync } from "../utils/catchAsync";
import {
  AddPasswordResetToken,
  CreateUserService,
  VerifyPassword,
} from "../../modules/user/user.service";
import AppError from "../utils/AppError";
import {
  createUserSchema,
  emailOnlySchema,
  UpdateUserInput,
  UserPartialType,
} from "../../modules/user/user.schema";
import {
  getUser,
  getUserByEmailAuth,
  updateUser,
} from "../../modules/user/user.repository";
import sendEmail from "../utils/sendEmail";
import prisma from "../../../prisma/db";
import crypto from "crypto";

export const generateToken = (id: string): string => {
  const Secret = process.env.JWT_SECRET as string;
  const Expiry = process.env.JWT_EXPIRY as string;
  if (!Secret)
    throw new AppError("No secret for the jwt token specified!", 400);
  if (!Expiry)
    throw new AppError("No Expiry date for the jwt token specified!", 400);

  const token = jwt.sign({ id: id }, Secret, {
    expiresIn: Expiry,
  } as jwt.SignOptions);
  return token;
};

export const signup = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const validatedData = createUserSchema.safeParse(req.body);
    if (!validatedData.success || validatedData.error) {
      return next(new AppError(validatedData.error.message, 400));
    }
    const user = await CreateUserService(validatedData.data);
    const token = generateToken(user.id);

    res.status(201).json({
      status: "success",
      token,
      data: {
        user,
      },
    });
  },
);

export const login = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { email, password } = req.body;
    if (!email || !password) {
      return next(new AppError("Please provide email and password", 400));
    }
    const user = await getUserByEmailAuth(email);
    if (!user || !(await VerifyPassword(password, user.password))) {
      return next(new AppError(`Wrong Email or Password`, 404));
    }
    const token = generateToken(user.id);
    const newuser = await getUser(user.id);
    console.log("\n Login token has been issued\n");
    res.status(200).json({
      status: "Success",
      token,
      data: newuser,
    });
  },
);

export const protectRoute = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    // Check if there is a token in the headers
    let token: string = "";
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      token = req.headers.authorization.split(" ")[1];
    } else {
      return next(new AppError("You are not logged in ,Please login in!", 401));
    }

    // Verify the token
    let payload: any = {};
    const verify_token = promisify(jwt.verify) as (
      token: string,
      secret: jwt.Secret,
    ) => Promise<any>;
    try {
      const verified_token_data = await verify_token(
        token,
        process.env.JWT_SECRET as jwt.Secret,
      );
      payload = verified_token_data;
    } catch (error) {
      return next(
        new AppError(
          "Gotcha mother fucker, Go Login or make an account!!!",
          401,
        ),
      );
    }

    // check if the user with that token still exists
    const userid = payload.id;
    if (!userid) {
      return next(new AppError(`Please login again`, 401));
    }
    const finduser = await getUser(userid);
    if (!finduser) {
      return next(new AppError("please login again", 401));
    }

    let passwordupdatedat = finduser.passwordUpdatedAt;
    if (passwordupdatedat) {
      passwordupdatedat = new Date(passwordupdatedat);
      const pass_time = Math.floor(passwordupdatedat.getTime() / 1000);
      const token_time = payload.iat;
      if (pass_time > token_time) {
        console.log(
          "\n\nPassword changed at: ",
          pass_time,
          "  \n\n\n user issued token at : ",
          token_time,
        );
        return next(
          new AppError(
            `Password has recently changed, please login again`,
            401,
          ),
        );
      }
    }

    req.user = finduser;
    next();
  },
);

export const forgotPassword = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { email } = { ...req.body };
    const validdata = emailOnlySchema.safeParse({ email });
    if (!validdata.success) {
      return next(new AppError(`${validdata.error.message}`, 400));
    }
    const finduser = await getUserByEmailAuth(validdata.data.email);
    if (!finduser) {
      return next(new AppError("Invalid email, please try again!", 404));
    }

    const reset_token = await AddPasswordResetToken(finduser.id);
    const reset_url = `${req.protocol}://${req.get(
      "host",
    )}/api/v1/users/resetPassword/${reset_token}`;
    const message = `Forgot your password?, Please make a PATCH request with your new password and confirm your password on the url: ${reset_url}\nIf you didn't forget
    your password, Please Ignore this email!`;

    try {
      await sendEmail({
        to: finduser.email,
        subject: `Your password reset email, (Valid for 10 minutes only!!!)`,
        text: message,
      });

      res.status(200).json({
        status: "success",
        message: "Token sent to email!",
      });
    } catch (error) {
      await prisma.user.update({
        where: { id: finduser.id },
        data: {
          passwordResetToken: null,
          passwordResetTokenExpiry: null,
        },
      });
      const err = error as Error;
      return next(
        new AppError(
          `Something went wrong when sending the token to the user email || ${err.message}`,
          500,
        ),
      );
    }
  },
);

export const resetPassword = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const url_token = req.params.token;
    const hashed_token = crypto
      .createHash("sha256")
      .update(url_token)
      .digest("hex");
    const user = await prisma.user.findFirstOrThrow({
      where: {
        passwordResetToken: hashed_token,
        passwordResetTokenExpiry: { gt: new Date() },
      },
    });
    if (!user) {
      return next(
        new AppError(`Can't find this user, maybe the token has expired`, 404),
      );
    }
    let { password } = req.body;
    const validpassword = UpdateUserInput.safeParse({ password });
    if (!validpassword.success) {
      return next(new AppError(`${validpassword.error.message}`, 400));
    }
    const newpassword = await bcrypt.hash(
      validpassword.data.password as string,
      Number(process.env.SALT) || 10,
    );

    const user_with_new_password = await updateUser(user.id, {
      password: newpassword,
      passwordUpdatedAt: new Date(Date.now()),
      passwordResetToken: null,
      passwordResetTokenExpiry: null,
    });

    const token = generateToken(user_with_new_password.id);
    req.user = user_with_new_password;
    res.status(200).json({
      status: "success",
      message: "user password updated",
      token,
      data: user_with_new_password,
    });
  },
);

export const GetMe = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.headers || !req.headers.authorization) {
      return next(new AppError("This route should be protected", 403));
    }
    const token = req.headers.authorization.split(" ")[1];
    if (!token) {
      return next(new AppError(`There  is no token, please login again!`, 403));
    }
    // Verify the token
    let payload: any = {};
    const verify_token = promisify(jwt.verify) as (
      token: string,
      secret: jwt.Secret,
    ) => Promise<any>;
    try {
      const verified_token_data = await verify_token(
        token,
        process.env.JWT_SECRET as jwt.Secret,
      );
      payload = verified_token_data;
    } catch (error) {
      return next(
        new AppError(
          "Gotcha mother fucker, Go Login or make an account!!!",
          401,
        ),
      );
    }
    const user = await getUser(payload.id);
    res.status(200).json({
      status: "success",
      data: user,
    });
  },
);
import {Request , Response,  NextFunction } from "express";
import { catchAsync } from "../utils/catchAsync";
import AppError from "../utils/AppError";
import { getUser } from "../../modules/user/user.repository";



// export const GetChiefsMenuItem = catchAsync(
//     async(req: Request , res:Response , next: NextFunction) => {
//         if(!req.user){
//             return next(new AppError("You are not logged in , please log in",401));
//         }
//         const user = req.user ; 
//         if(user.role !== 'CHIEF'){
//             return next(new AppError('You are not a chief to perform this action',401));
//         }
//         next(); 
//     }
// );



// export const CheckChefExists= catchAsync(
//     async (req:Request , res: Response ,next: NextFunction) => {
//         const chefid = req.params.chefid ; 
//         if(!chefid){
//             return next(new AppError("Not enough data to get the chef" , 404)) ;
//         }
//         const chef = await getUser(chefid);
//         if(!chef || chef.role !== 'CHEF'){
//             return next(new AppError(`This user is not authorized to have a menu  item` , 401));
//         }
//         next();
//     }
// )import { Request, Response, NextFunction } from "express";
import AppError from "../utils/AppError";
import { Prisma } from "@prisma/client";
import { ZodError } from "zod";

export const globalErrorHandler = (
  err: any,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  sendError(err, req, res, next);
};

export const sendPrismaError = (error: any) => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2002":
        return new AppError("Resource already exists", 409);
      case "P2025":
        return new AppError("Resource not found", 404);
      case "P2003":
        return new AppError("Invalid Reference", 400);
      default:
        return new AppError("Database Error", 500);
    }
  }
  return new AppError("unexpected DB error", 400);
};

export const sendZodError = (error: ZodError): AppError => {
  const errorMessage = `
    ${error.name},
      ${error.message},
      ${error.issues},
      Happened at: --> ${error.stack}
    `;
  return new AppError(errorMessage, 400);
};

const sendErrorDev = (err: AppError, res: Response) => {
  res.status(err.statusCode).json({
    status: err.status,
    message: err.message,
    stack: err.stack,
  });
};

const sendErrorProd = (err: AppError, res: Response) => {
  res.status(err.statusCode).json({
    status: err.status,
    message: err.message,
  });
};

const sendError = (
  err: any,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  if (process.env.NODE_ENV === "development") {
    // Check if the error is prisma error and modify:
    //message
    //status code
    sendErrorDev(err, res);
  } else if (process.env.NODE_ENV === "production") {
    // just send the error message and don't send the error stack
    sendErrorProd(err, res);
  }
};
import { Role } from "@prisma/client"
import {Request , Response , NextFunction} from 'express';
import { catchAsync } from "../utils/catchAsync";
import AppError from "../utils/AppError";

const restrictTo = (...roles: Role[])=> {
 return (req: Request, res: Response, next: NextFunction) => {
    const current_user = req.user;
    if (!current_user) {
      return next(
        new AppError("No User found login in, something went wrong ", 403)
      );
    }

    if (!roles.includes(current_user.role)) {
      return next(
        new AppError("You are not authorized to perform this action!", 403)
      );
    }

    next();
  };
};

export default restrictTo; 