import { Response, Request, NextFunction } from "express";
import { catchAsync } from "../../common/utils/catchAsync";
import { createNewOrder, deleteOrder } from "./order.repository";
import AppError from "../../common/utils/AppError";
import { CreateOrderService } from "./order.service";
import { apiResponse } from "../../common/utils/ApiResponse";

export const CreateNewOrder = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { userid, chefid, items } = req.body;
    if (!userid || !chefid) {
      return next(
        new AppError(`Please makesure to provide the user and chef ids`, 404),
      );
    }
    if (!items || items.length === 0) {
      return next(
        new AppError(
          "There must be at least 1 order item in order to complete this order",
          400,
        ),
      );
    }
    const fullorder = await CreateOrderService(userid, chefid, items);
    apiResponse(res, "success", 200, fullorder);
  },
);

export const DeleteOrder = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const id = req.params.id;
    if (!id) {
      return apiResponse(
        res,
        "failed",
        404,
        undefined,
        "There is no id provided for deleting the order",
      );
    }
    const deletedOrder = await deleteOrder(id);
    apiResponse(res, "success", 402);
  },
);
import { Prisma, Order } from "@prisma/client";
import { sendPrismaError } from "../../common/middelware/errorhandler.middleware";
import prisma from "../../../prisma/db";
import AppError from "../../common/utils/AppError";

export type orderItemInput = {
  menuitem_id: string;
  quantity: number;
  item_price: number;
};

export type FullOrder = Prisma.OrderGetPayload<{
  include: {
    orderitems: {
      include: { menuitem: true };
    };
  };
}>;

export async function createNewOrder(
  userid: string,
  chefid: string,
  items: orderItemInput[],
): Promise<FullOrder> {
  try {
    return await prisma.$transaction(async (tx) => {
      const order = await tx.order.create({
        data: {
          customer_id: userid,
          chef_id: chefid,
          total_price: items.reduce(
            (sum, i) => sum + i.item_price * i.quantity,
            0,
          ),
          order_status: "PENDING",
        },
      });

      await tx.orderItem.createMany({
        data: items.map((item) => ({
          quantity: item.quantity,
          item_price: item.item_price,
          menuitem_id: item.menuitem_id,
          order_id: order.id,
        })),
      });
      const fullorder = await tx.order.findUniqueOrThrow({
        where: { id: order.id },
        include: {
          orderitems: {
            include: {
              menuitem: true,
            },
          },
        },
      });
      return fullorder;
    });
  } catch (error) {
    throw sendPrismaError(error);
  }
}

export async function deleteOrder(id: string) {
  try {
    await prisma.order.delete({ where: { id } });
  } catch (error) {
    throw sendPrismaError(error);
  }
}

export async function GetOrderById(id: string): Promise<Order | null> {
  try {
    return await prisma.order.findUniqueOrThrow({
      where: { id },
      include: {
        orderitems: {
          include: { menuitem: true },
        },
        customer: true,
        chef: true,
      },
    });
  } catch (error) {
    throw sendPrismaError(error);
  }
}
import { protectRoute } from "../../common/middelware/auth.middleware";
import { CreateNewOrder, DeleteOrder } from "./order.controller";
import { Router } from "express";

const router = Router();
router.use(protectRoute);
router.route("/").get(CreateNewOrder);
router.route("/:id").delete(DeleteOrder);
export default router;
import { sendPrismaError } from "../../common/middelware/errorhandler.middleware";
import AppError from "../../common/utils/AppError";
import { createNewOrder, FullOrder, orderItemInput } from "./order.repository";
import prisma from "../../../prisma/db";

export const CreateOrderService = async (
  userid: string,
  chefid: string,
  items: orderItemInput[],
) => {
  try {
    if (userid === chefid) {
      throw new AppError("You can't order from your self", 400);
    }
    await prisma.user.findUniqueOrThrow({
      where: { id: chefid },
    });
    await prisma.user.findUniqueOrThrow({
      where: { id: userid },
    });
    return await createNewOrder(userid, chefid, items);
  } catch (error) {
    throw sendPrismaError(error);
  }
};
import { Prisma, OrderItem } from "@prisma/client";
import prisma from "../../../prisma/db";
import { sendPrismaError } from "../../common/middelware/errorhandler.middleware";

export async function createOrderItem(
  data: Prisma.OrderItemCreateInput,
): Promise<OrderItem> {
  try {
    return await prisma.orderItem.create({ data });
  } catch (error) {
    throw sendPrismaError(error);
  }
}

export async function createOrderItems(
  data: Prisma.OrderItemCreateManyInput[],
): Promise<{ count: number }> {
  return await prisma.orderItem.createMany({ data });
}

export async function updateOrderItem(
  data: Prisma.OrderItemUpdateInput,
  id: string,
): Promise<OrderItem> {
  try {
    const { quantity } = data;

    return await prisma.orderItem.update({
      where: { id },
      data: { quantity: quantity },
    });
  } catch (error) {
    throw sendPrismaError(error);
  }
}

export async function deleteOrderItem(id: string) {
  try {
    await prisma.orderItem.delete({ where: { id } });
  } catch (error) {
    throw sendPrismaError(error);
  }
}

export async function getOrderItem(id: string) {
  try {
    return await prisma.orderItem.findUniqueOrThrow({ where: { id } });
  } catch (error) {
    throw sendPrismaError(error);
  }
}
import {
  getAllMenuItems,
  deleteMenuItem,
  updateMenuItem,
  getMenuItem,
  getAllMenuItemsAdmin,
  getMenuItemBySlug,
} from "./menuitem.repository";
import { buildPrismaQuery } from "../../common/utils/queryBuilder";
import { catchAsync } from "../../common/utils/catchAsync";
import { Request, Response, NextFunction } from "express";
import { MenuItemSchema, UpdateMenuSchema } from "./menuitem.schema";
import AppError from "../../common/utils/AppError";
import { CreateMenuItemService } from "./menuitem.service";
import { Role } from "@prisma/client";
import { apiResponse } from "../../common/utils/ApiResponse";
import { sendZodError } from "../../common/middelware/errorhandler.middleware";

export const CreateNewItem = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    let chefid = "";
    if (!req.user) {
      return next(
        new AppError("There is no logged in user to complete this action", 401),
      );
    }
    if (req.user.role === Role.CHEF) {
      chefid = req.user.id;
    } else if (req.user.role === Role.ADMIN) {
      chefid = req.body.chefid;
    } else {
      return next(
        new AppError(`You aren't authorized to perform this action`, 401),
      );
    }
    if (!chefid) {
      return next(
        new AppError(`There is no chef id associated with this item`, 404),
      );
    }
    const rawdata = { chef_id: chefid, ...req.body };
    const parsed = MenuItemSchema.safeParse(rawdata);
    if (!parsed.success) {
      return next(new AppError(`${parsed.error.message}`, 400));
    }
    const data = parsed.data;
    const item = await CreateMenuItemService(data);
    apiResponse(res, "success", 200, item);
  },
);

export const DeleteMenuItem = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const id = req.params.id;
    let chefid;
    if (!req.user) {
      return next(
        new AppError(`There is no chef associated with this item`, 404),
      );
    } else if (req.user.role === Role.CHEF) {
      chefid = req.user.id;
      console.log("Current user: ", req.user.id);
    } else if (req.user.role === Role.ADMIN) {
      chefid = req.body.chefid;
      if (!chefid) {
        return next(
          new AppError(
            `since you are an admin provide chef id in the request body as <chefid>`,
            400,
          ),
        );
      }
    }
    const finditem = await getMenuItem(id, chefid);
    if (!finditem) {
      return next(new AppError("Could not find this item for deleting!!", 404));
    }
    await deleteMenuItem(finditem.id);
    apiResponse(res, "success", 204);
  },
);

export const GetMenuItemByID = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const id = req.params.id;
    const user = req.user;
    if (!user || user.role !== "CHEF") {
      return next(new AppError("This chief doesn't exists!", 404));
    }
    const finditem = await getMenuItem(id, user.id);
    if (!finditem) {
      return next(new AppError("Could not find this item for deleting!!", 404));
    }
    apiResponse(res, "success", 200, finditem);
  },
);

export const GetAllMenuItems = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const options = buildPrismaQuery(req.query);
    let chefid = "";
    if (!req.user) {
      return next(new AppError(`There is no authenticated user`, 401));
    }
    if (req.user?.role === Role.CHEF) {
      chefid = req.user.id;
    } else if (req.user.role === Role.ADMIN) {
      chefid = req.params.chefid;
    }
    const allMenuItems = await getAllMenuItems(options, chefid);
    apiResponse(
      res,
      "success",
      200,
      allMenuItems,
      undefined,
      allMenuItems.length,
    );
  },
);

export const UpdateMenuItem = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const id = req.params.id;
    let filtereddata;
    let chiefid;
    // if (req.body.chief_id) {
    //   const { chief_id, ...rest } = req.body;
    //   filtereddata = rest;
    //   chiefid = chief_id;
    // }
    const validData = UpdateMenuSchema.safeParse(req.body);
    if (!validData.success) {
      return next(sendZodError(validData.error));
    }
    if (!req.user) {
      return next(
        new AppError("Please login inorder to complete this action!", 403),
      );
    } else if (req.user.role !== Role.CHEF) {
      return next(
        new AppError("You arenot authorized to do this action !!", 403),
      );
    }
    const finditem = await getMenuItem(id, req.user.id);
    if (!finditem) {
      return next(new AppError("Can not find this item!!", 404));
    }
    const updateItem = await updateMenuItem(validData.data, id);
    apiResponse(res, "success", 200, updateItem);
  },
);

export const GetAllMenuItemsAdmin = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const options = buildPrismaQuery(req.query);
    const data = await getAllMenuItemsAdmin(options);
    apiResponse(res, "success", 200, data, undefined, data.length);
  },
);

// TODO : Fix this Implementation
export const GetAllMenuItemsBySlug = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const item_name = req.params.item_name;
    if (!item_name) {
      return next(new AppError(`Please provide the item's name`, 400));
    }
    const item = await getMenuItemBySlug(item_name);
    if (!item) {
      return next(new AppError(`Couldn't find this item`, 404));
    }

    apiResponse(res, "success", 200, item);
  },
);
import prisma from "../../../prisma/db";
import { sendPrismaError } from "../../common/middelware/errorhandler.middleware";
import { Prisma, MenuItem } from "@prisma/client";

export async function createMenuItem(
  data: Prisma.MenuItemCreateInput,
): Promise<MenuItem> {
  try {
    return await prisma.menuItem.create({ data });
  } catch (error) {
    throw sendPrismaError(error);
  }
}

export async function updateMenuItem(
  data: Prisma.MenuItemUpdateInput,
  id: string
): Promise<MenuItem> {
  try {
    return await prisma.menuItem.update({ where: { id }, data });
  } catch (error) {
    throw sendPrismaError(error);
  }
}

export async function deleteMenuItem(id: string) {
  try {
    await prisma.menuItem.delete({ where: { id } });
  } catch (error) {
    throw sendPrismaError(error);
  }
}

export async function getMenuItem(
  id: string,
  chiefid: string
): Promise<MenuItem | null> {
  try {
    return await prisma.menuItem.findUniqueOrThrow({
      where: { id: id, chef_id: chiefid },
      include:{
        chef:{
          select: {
            name: true , 
          }
        }
      }
    });
  } catch (error) {
    throw sendPrismaError(error);
  }
}

export async function getAllMenuItems(
  options: Prisma.MenuItemFindManyArgs, 
  chiefid: string
): Promise<MenuItem[]> {
  try {
    return await prisma.menuItem.findMany({
      ...options,
      where:{chef_id: chiefid},
    });
  } catch (error) {
    throw sendPrismaError(error);
  }
}


export async function getAllMenuItemsAdmin(
  options: Prisma.MenuItemFindManyArgs,
): Promise<MenuItem[]>{
  try {
    return await prisma.menuItem.findMany({
      ...options , 
      include:{
        chef: {
          select:{
            name: true, 
            email: true, 
            id: true
          }
        }
      },
      
    }) 
  } catch (error) {
   throw sendPrismaError(error); 
  }
}

export async function getMenuItemBySlug(slug: string): Promise<MenuItem | null>{
  try {
   return await prisma.menuItem.findFirstOrThrow({where:{slug} , include:{chef:{
    select:{
      name: true
    }
   }
   }}) 
  } catch (error) {
   throw sendPrismaError(error); 
  }
}import { Router } from "express";
import {
  CreateNewItem,
  GetAllMenuItems,
  DeleteMenuItem,
  UpdateMenuItem,
  GetAllMenuItemsAdmin,
} from "./menuitem.controller";
import { protectRoute } from "../../common/middelware/auth.middleware";
import { Role } from "@prisma/client";
import restrictTo from "../../common/middelware/restrictTo";

const router = Router();

router.route("/public/:chefid").get(protectRoute, GetAllMenuItems);
//ADMIN ONLY ROUTE
router
  .route("/admin")
  .get(protectRoute, restrictTo(Role.ADMIN), GetAllMenuItemsAdmin);

// CHEFS ROUTES //
router
  .route("/")
  .post(protectRoute, restrictTo(Role.ADMIN, Role.CHEF), CreateNewItem)
  .get(protectRoute, restrictTo(Role.ADMIN, Role.CHEF), GetAllMenuItems);

// PUBLIC  //
///////////////////////////////////////////////////////////
router
  .route("/:id")
  .patch(protectRoute, restrictTo(Role.ADMIN, Role.CHEF), UpdateMenuItem)
  .delete(protectRoute, restrictTo(Role.ADMIN, Role.CHEF), DeleteMenuItem);

export default router;
import { FoodType, ItemType } from '@prisma/client';
import { z } from 'zod';

export const MenuItemSchema = z.object({
  name: z.string()
    .min(3, 'Item name should be at least 3 characters')
    .max(32, 'Item name should be at most 32 characters')
    .regex(/^[\p{L}\p{N} ]+$/u, "Name may only contain letters, numbers and spaces")
    .transform(val => val.trim()),
  description: z.string()
    .min(10, 'Description should be at least 10 characters')
    .max(500, 'Description should be at most 500 characters')
    .transform(val => val.trim()),
  
  price: z.coerce.number()
    .positive("Price must be positive")
    .max(10000, "Price seems unreasonably high")
    .multipleOf(0.01, "Price can have at most 2 decimal places"),
  
  foodType: z.enum(FoodType).default("ARABIAN"),
  
  itemType: z.enum(ItemType).default("MAINDISH"),
  slug:z.string().optional(), 
  chef_id: z.string()
    .min(1, "Chief ID is required")
    .regex(/^c[a-z0-9]{24}$/i, "Invalid chief ID format"),

});

export type CreateMenuItemInput  = z.infer<typeof MenuItemSchema> ;
export const UpdateMenuSchema = MenuItemSchema.partial();import slugify from "slugify";
import { createMenuItem } from "./menuitem.repository";
import { MenuItem, Role } from "@prisma/client";
import { Prisma } from "@prisma/client";
import { CreateMenuItemInput } from "./menuitem.schema";

export const CreateMenuItemService = async(data: CreateMenuItemInput) : Promise<MenuItem>=>{
    const item_slug = slugify(data.name , {lower: true , trim: true}) ; 
    const {chef_id , ...rest} = data ; 
    const prismadata: Prisma.MenuItemCreateInput = {
        ...rest , 
        slug: item_slug,
        chef:{
            connect:{
                id: chef_id
            }
        }
    }
    return await createMenuItem(prismadata) ; 
}